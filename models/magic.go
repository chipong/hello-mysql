// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Magic is an object representing the database table.
type Magic struct {
	ID           int          `boil:"id" json:"id" toml:"id" yaml:"id"`
	IDTwo        int          `boil:"id_two" json:"id_two" toml:"id_two" yaml:"id_two"`
	IDThree      null.Int     `boil:"id_three" json:"id_three,omitempty" toml:"id_three" yaml:"id_three,omitempty"`
	BoolZero     null.Int8    `boil:"bool_zero" json:"bool_zero,omitempty" toml:"bool_zero" yaml:"bool_zero,omitempty"`
	BoolOne      null.Int8    `boil:"bool_one" json:"bool_one,omitempty" toml:"bool_one" yaml:"bool_one,omitempty"`
	BoolTwo      int8         `boil:"bool_two" json:"bool_two" toml:"bool_two" yaml:"bool_two"`
	BoolThree    null.Int8    `boil:"bool_three" json:"bool_three,omitempty" toml:"bool_three" yaml:"bool_three,omitempty"`
	BoolFour     null.Int8    `boil:"bool_four" json:"bool_four,omitempty" toml:"bool_four" yaml:"bool_four,omitempty"`
	BoolFive     int8         `boil:"bool_five" json:"bool_five" toml:"bool_five" yaml:"bool_five"`
	BoolSix      int8         `boil:"bool_six" json:"bool_six" toml:"bool_six" yaml:"bool_six"`
	StringZero   null.String  `boil:"string_zero" json:"string_zero,omitempty" toml:"string_zero" yaml:"string_zero,omitempty"`
	StringOne    null.String  `boil:"string_one" json:"string_one,omitempty" toml:"string_one" yaml:"string_one,omitempty"`
	StringTwo    string       `boil:"string_two" json:"string_two" toml:"string_two" yaml:"string_two"`
	StringThree  null.String  `boil:"string_three" json:"string_three,omitempty" toml:"string_three" yaml:"string_three,omitempty"`
	StringFour   string       `boil:"string_four" json:"string_four" toml:"string_four" yaml:"string_four"`
	StringFive   null.String  `boil:"string_five" json:"string_five,omitempty" toml:"string_five" yaml:"string_five,omitempty"`
	StringSix    null.String  `boil:"string_six" json:"string_six,omitempty" toml:"string_six" yaml:"string_six,omitempty"`
	StringSeven  string       `boil:"string_seven" json:"string_seven" toml:"string_seven" yaml:"string_seven"`
	StringEight  null.String  `boil:"string_eight" json:"string_eight,omitempty" toml:"string_eight" yaml:"string_eight,omitempty"`
	StringNine   string       `boil:"string_nine" json:"string_nine" toml:"string_nine" yaml:"string_nine"`
	StringTen    null.String  `boil:"string_ten" json:"string_ten,omitempty" toml:"string_ten" yaml:"string_ten,omitempty"`
	StringEleven string       `boil:"string_eleven" json:"string_eleven" toml:"string_eleven" yaml:"string_eleven"`
	BigIntZero   null.Int64   `boil:"big_int_zero" json:"big_int_zero,omitempty" toml:"big_int_zero" yaml:"big_int_zero,omitempty"`
	BigIntOne    null.Int64   `boil:"big_int_one" json:"big_int_one,omitempty" toml:"big_int_one" yaml:"big_int_one,omitempty"`
	BigIntTwo    int64        `boil:"big_int_two" json:"big_int_two" toml:"big_int_two" yaml:"big_int_two"`
	BigIntThree  null.Int64   `boil:"big_int_three" json:"big_int_three,omitempty" toml:"big_int_three" yaml:"big_int_three,omitempty"`
	BigIntFour   int64        `boil:"big_int_four" json:"big_int_four" toml:"big_int_four" yaml:"big_int_four"`
	BigIntFive   null.Int64   `boil:"big_int_five" json:"big_int_five,omitempty" toml:"big_int_five" yaml:"big_int_five,omitempty"`
	BigIntSix    int64        `boil:"big_int_six" json:"big_int_six" toml:"big_int_six" yaml:"big_int_six"`
	IntZero      null.Int     `boil:"int_zero" json:"int_zero,omitempty" toml:"int_zero" yaml:"int_zero,omitempty"`
	IntOne       null.Int     `boil:"int_one" json:"int_one,omitempty" toml:"int_one" yaml:"int_one,omitempty"`
	IntTwo       int          `boil:"int_two" json:"int_two" toml:"int_two" yaml:"int_two"`
	IntThree     null.Int     `boil:"int_three" json:"int_three,omitempty" toml:"int_three" yaml:"int_three,omitempty"`
	IntFour      int          `boil:"int_four" json:"int_four" toml:"int_four" yaml:"int_four"`
	IntFive      null.Int     `boil:"int_five" json:"int_five,omitempty" toml:"int_five" yaml:"int_five,omitempty"`
	IntSix       int          `boil:"int_six" json:"int_six" toml:"int_six" yaml:"int_six"`
	FloatZero    null.Float32 `boil:"float_zero" json:"float_zero,omitempty" toml:"float_zero" yaml:"float_zero,omitempty"`
	FloatOne     null.Float32 `boil:"float_one" json:"float_one,omitempty" toml:"float_one" yaml:"float_one,omitempty"`
	FloatTwo     null.Float32 `boil:"float_two" json:"float_two,omitempty" toml:"float_two" yaml:"float_two,omitempty"`
	FloatThree   null.Float32 `boil:"float_three" json:"float_three,omitempty" toml:"float_three" yaml:"float_three,omitempty"`
	FloatFour    null.Float32 `boil:"float_four" json:"float_four,omitempty" toml:"float_four" yaml:"float_four,omitempty"`
	FloatFive    float32      `boil:"float_five" json:"float_five" toml:"float_five" yaml:"float_five"`
	FloatSix     null.Float32 `boil:"float_six" json:"float_six,omitempty" toml:"float_six" yaml:"float_six,omitempty"`
	FloatSeven   float32      `boil:"float_seven" json:"float_seven" toml:"float_seven" yaml:"float_seven"`
	FloatEight   null.Float32 `boil:"float_eight" json:"float_eight,omitempty" toml:"float_eight" yaml:"float_eight,omitempty"`
	FloatNine    null.Float32 `boil:"float_nine" json:"float_nine,omitempty" toml:"float_nine" yaml:"float_nine,omitempty"`
	ByteaZero    null.Bytes   `boil:"bytea_zero" json:"bytea_zero,omitempty" toml:"bytea_zero" yaml:"bytea_zero,omitempty"`
	ByteaOne     null.Bytes   `boil:"bytea_one" json:"bytea_one,omitempty" toml:"bytea_one" yaml:"bytea_one,omitempty"`
	ByteaTwo     []byte       `boil:"bytea_two" json:"bytea_two" toml:"bytea_two" yaml:"bytea_two"`
	ByteaThree   []byte       `boil:"bytea_three" json:"bytea_three" toml:"bytea_three" yaml:"bytea_three"`
	ByteaFour    null.Bytes   `boil:"bytea_four" json:"bytea_four,omitempty" toml:"bytea_four" yaml:"bytea_four,omitempty"`
	ByteaFive    []byte       `boil:"bytea_five" json:"bytea_five" toml:"bytea_five" yaml:"bytea_five"`
	ByteaSix     null.Bytes   `boil:"bytea_six" json:"bytea_six,omitempty" toml:"bytea_six" yaml:"bytea_six,omitempty"`
	ByteaSeven   []byte       `boil:"bytea_seven" json:"bytea_seven" toml:"bytea_seven" yaml:"bytea_seven"`
	ByteaEight   []byte       `boil:"bytea_eight" json:"bytea_eight" toml:"bytea_eight" yaml:"bytea_eight"`
	TimeZero     null.Time    `boil:"time_zero" json:"time_zero,omitempty" toml:"time_zero" yaml:"time_zero,omitempty"`
	TimeOne      null.Time    `boil:"time_one" json:"time_one,omitempty" toml:"time_one" yaml:"time_one,omitempty"`
	TimeTwo      null.Time    `boil:"time_two" json:"time_two,omitempty" toml:"time_two" yaml:"time_two,omitempty"`
	TimeThree    null.Time    `boil:"time_three" json:"time_three,omitempty" toml:"time_three" yaml:"time_three,omitempty"`
	TimeFive     null.Time    `boil:"time_five" json:"time_five,omitempty" toml:"time_five" yaml:"time_five,omitempty"`
	TimeNine     time.Time    `boil:"time_nine" json:"time_nine" toml:"time_nine" yaml:"time_nine"`
	TimeEleven   null.Time    `boil:"time_eleven" json:"time_eleven,omitempty" toml:"time_eleven" yaml:"time_eleven,omitempty"`
	TimeTwelve   time.Time    `boil:"time_twelve" json:"time_twelve" toml:"time_twelve" yaml:"time_twelve"`
	TimeFifteen  null.Time    `boil:"time_fifteen" json:"time_fifteen,omitempty" toml:"time_fifteen" yaml:"time_fifteen,omitempty"`
	TimeSixteen  time.Time    `boil:"time_sixteen" json:"time_sixteen" toml:"time_sixteen" yaml:"time_sixteen"`

	R *magicR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L magicL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MagicColumns = struct {
	ID           string
	IDTwo        string
	IDThree      string
	BoolZero     string
	BoolOne      string
	BoolTwo      string
	BoolThree    string
	BoolFour     string
	BoolFive     string
	BoolSix      string
	StringZero   string
	StringOne    string
	StringTwo    string
	StringThree  string
	StringFour   string
	StringFive   string
	StringSix    string
	StringSeven  string
	StringEight  string
	StringNine   string
	StringTen    string
	StringEleven string
	BigIntZero   string
	BigIntOne    string
	BigIntTwo    string
	BigIntThree  string
	BigIntFour   string
	BigIntFive   string
	BigIntSix    string
	IntZero      string
	IntOne       string
	IntTwo       string
	IntThree     string
	IntFour      string
	IntFive      string
	IntSix       string
	FloatZero    string
	FloatOne     string
	FloatTwo     string
	FloatThree   string
	FloatFour    string
	FloatFive    string
	FloatSix     string
	FloatSeven   string
	FloatEight   string
	FloatNine    string
	ByteaZero    string
	ByteaOne     string
	ByteaTwo     string
	ByteaThree   string
	ByteaFour    string
	ByteaFive    string
	ByteaSix     string
	ByteaSeven   string
	ByteaEight   string
	TimeZero     string
	TimeOne      string
	TimeTwo      string
	TimeThree    string
	TimeFive     string
	TimeNine     string
	TimeEleven   string
	TimeTwelve   string
	TimeFifteen  string
	TimeSixteen  string
}{
	ID:           "id",
	IDTwo:        "id_two",
	IDThree:      "id_three",
	BoolZero:     "bool_zero",
	BoolOne:      "bool_one",
	BoolTwo:      "bool_two",
	BoolThree:    "bool_three",
	BoolFour:     "bool_four",
	BoolFive:     "bool_five",
	BoolSix:      "bool_six",
	StringZero:   "string_zero",
	StringOne:    "string_one",
	StringTwo:    "string_two",
	StringThree:  "string_three",
	StringFour:   "string_four",
	StringFive:   "string_five",
	StringSix:    "string_six",
	StringSeven:  "string_seven",
	StringEight:  "string_eight",
	StringNine:   "string_nine",
	StringTen:    "string_ten",
	StringEleven: "string_eleven",
	BigIntZero:   "big_int_zero",
	BigIntOne:    "big_int_one",
	BigIntTwo:    "big_int_two",
	BigIntThree:  "big_int_three",
	BigIntFour:   "big_int_four",
	BigIntFive:   "big_int_five",
	BigIntSix:    "big_int_six",
	IntZero:      "int_zero",
	IntOne:       "int_one",
	IntTwo:       "int_two",
	IntThree:     "int_three",
	IntFour:      "int_four",
	IntFive:      "int_five",
	IntSix:       "int_six",
	FloatZero:    "float_zero",
	FloatOne:     "float_one",
	FloatTwo:     "float_two",
	FloatThree:   "float_three",
	FloatFour:    "float_four",
	FloatFive:    "float_five",
	FloatSix:     "float_six",
	FloatSeven:   "float_seven",
	FloatEight:   "float_eight",
	FloatNine:    "float_nine",
	ByteaZero:    "bytea_zero",
	ByteaOne:     "bytea_one",
	ByteaTwo:     "bytea_two",
	ByteaThree:   "bytea_three",
	ByteaFour:    "bytea_four",
	ByteaFive:    "bytea_five",
	ByteaSix:     "bytea_six",
	ByteaSeven:   "bytea_seven",
	ByteaEight:   "bytea_eight",
	TimeZero:     "time_zero",
	TimeOne:      "time_one",
	TimeTwo:      "time_two",
	TimeThree:    "time_three",
	TimeFive:     "time_five",
	TimeNine:     "time_nine",
	TimeEleven:   "time_eleven",
	TimeTwelve:   "time_twelve",
	TimeFifteen:  "time_fifteen",
	TimeSixteen:  "time_sixteen",
}

var MagicTableColumns = struct {
	ID           string
	IDTwo        string
	IDThree      string
	BoolZero     string
	BoolOne      string
	BoolTwo      string
	BoolThree    string
	BoolFour     string
	BoolFive     string
	BoolSix      string
	StringZero   string
	StringOne    string
	StringTwo    string
	StringThree  string
	StringFour   string
	StringFive   string
	StringSix    string
	StringSeven  string
	StringEight  string
	StringNine   string
	StringTen    string
	StringEleven string
	BigIntZero   string
	BigIntOne    string
	BigIntTwo    string
	BigIntThree  string
	BigIntFour   string
	BigIntFive   string
	BigIntSix    string
	IntZero      string
	IntOne       string
	IntTwo       string
	IntThree     string
	IntFour      string
	IntFive      string
	IntSix       string
	FloatZero    string
	FloatOne     string
	FloatTwo     string
	FloatThree   string
	FloatFour    string
	FloatFive    string
	FloatSix     string
	FloatSeven   string
	FloatEight   string
	FloatNine    string
	ByteaZero    string
	ByteaOne     string
	ByteaTwo     string
	ByteaThree   string
	ByteaFour    string
	ByteaFive    string
	ByteaSix     string
	ByteaSeven   string
	ByteaEight   string
	TimeZero     string
	TimeOne      string
	TimeTwo      string
	TimeThree    string
	TimeFive     string
	TimeNine     string
	TimeEleven   string
	TimeTwelve   string
	TimeFifteen  string
	TimeSixteen  string
}{
	ID:           "magic.id",
	IDTwo:        "magic.id_two",
	IDThree:      "magic.id_three",
	BoolZero:     "magic.bool_zero",
	BoolOne:      "magic.bool_one",
	BoolTwo:      "magic.bool_two",
	BoolThree:    "magic.bool_three",
	BoolFour:     "magic.bool_four",
	BoolFive:     "magic.bool_five",
	BoolSix:      "magic.bool_six",
	StringZero:   "magic.string_zero",
	StringOne:    "magic.string_one",
	StringTwo:    "magic.string_two",
	StringThree:  "magic.string_three",
	StringFour:   "magic.string_four",
	StringFive:   "magic.string_five",
	StringSix:    "magic.string_six",
	StringSeven:  "magic.string_seven",
	StringEight:  "magic.string_eight",
	StringNine:   "magic.string_nine",
	StringTen:    "magic.string_ten",
	StringEleven: "magic.string_eleven",
	BigIntZero:   "magic.big_int_zero",
	BigIntOne:    "magic.big_int_one",
	BigIntTwo:    "magic.big_int_two",
	BigIntThree:  "magic.big_int_three",
	BigIntFour:   "magic.big_int_four",
	BigIntFive:   "magic.big_int_five",
	BigIntSix:    "magic.big_int_six",
	IntZero:      "magic.int_zero",
	IntOne:       "magic.int_one",
	IntTwo:       "magic.int_two",
	IntThree:     "magic.int_three",
	IntFour:      "magic.int_four",
	IntFive:      "magic.int_five",
	IntSix:       "magic.int_six",
	FloatZero:    "magic.float_zero",
	FloatOne:     "magic.float_one",
	FloatTwo:     "magic.float_two",
	FloatThree:   "magic.float_three",
	FloatFour:    "magic.float_four",
	FloatFive:    "magic.float_five",
	FloatSix:     "magic.float_six",
	FloatSeven:   "magic.float_seven",
	FloatEight:   "magic.float_eight",
	FloatNine:    "magic.float_nine",
	ByteaZero:    "magic.bytea_zero",
	ByteaOne:     "magic.bytea_one",
	ByteaTwo:     "magic.bytea_two",
	ByteaThree:   "magic.bytea_three",
	ByteaFour:    "magic.bytea_four",
	ByteaFive:    "magic.bytea_five",
	ByteaSix:     "magic.bytea_six",
	ByteaSeven:   "magic.bytea_seven",
	ByteaEight:   "magic.bytea_eight",
	TimeZero:     "magic.time_zero",
	TimeOne:      "magic.time_one",
	TimeTwo:      "magic.time_two",
	TimeThree:    "magic.time_three",
	TimeFive:     "magic.time_five",
	TimeNine:     "magic.time_nine",
	TimeEleven:   "magic.time_eleven",
	TimeTwelve:   "magic.time_twelve",
	TimeFifteen:  "magic.time_fifteen",
	TimeSixteen:  "magic.time_sixteen",
}

// Generated where

type whereHelpernull_Int8 struct{ field string }

func (w whereHelpernull_Int8) EQ(x null.Int8) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int8) NEQ(x null.Int8) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int8) LT(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int8) LTE(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int8) GT(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int8) GTE(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int8) IN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int8) NIN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int8) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int8) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperint8 struct{ field string }

func (w whereHelperint8) EQ(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint8) NEQ(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint8) LT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint8) LTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint8) GT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint8) GTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint8) IN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint8) NIN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Float32 struct{ field string }

func (w whereHelpernull_Float32) EQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float32) NEQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float32) LT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float32) LTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float32) GT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float32) GTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float32) IN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float32) NIN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float32) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float32) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperfloat32 struct{ field string }

func (w whereHelperfloat32) EQ(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperfloat32) NEQ(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperfloat32) LT(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperfloat32) LTE(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperfloat32) GT(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperfloat32) GTE(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperfloat32) IN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperfloat32) NIN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var MagicWhere = struct {
	ID           whereHelperint
	IDTwo        whereHelperint
	IDThree      whereHelpernull_Int
	BoolZero     whereHelpernull_Int8
	BoolOne      whereHelpernull_Int8
	BoolTwo      whereHelperint8
	BoolThree    whereHelpernull_Int8
	BoolFour     whereHelpernull_Int8
	BoolFive     whereHelperint8
	BoolSix      whereHelperint8
	StringZero   whereHelpernull_String
	StringOne    whereHelpernull_String
	StringTwo    whereHelperstring
	StringThree  whereHelpernull_String
	StringFour   whereHelperstring
	StringFive   whereHelpernull_String
	StringSix    whereHelpernull_String
	StringSeven  whereHelperstring
	StringEight  whereHelpernull_String
	StringNine   whereHelperstring
	StringTen    whereHelpernull_String
	StringEleven whereHelperstring
	BigIntZero   whereHelpernull_Int64
	BigIntOne    whereHelpernull_Int64
	BigIntTwo    whereHelperint64
	BigIntThree  whereHelpernull_Int64
	BigIntFour   whereHelperint64
	BigIntFive   whereHelpernull_Int64
	BigIntSix    whereHelperint64
	IntZero      whereHelpernull_Int
	IntOne       whereHelpernull_Int
	IntTwo       whereHelperint
	IntThree     whereHelpernull_Int
	IntFour      whereHelperint
	IntFive      whereHelpernull_Int
	IntSix       whereHelperint
	FloatZero    whereHelpernull_Float32
	FloatOne     whereHelpernull_Float32
	FloatTwo     whereHelpernull_Float32
	FloatThree   whereHelpernull_Float32
	FloatFour    whereHelpernull_Float32
	FloatFive    whereHelperfloat32
	FloatSix     whereHelpernull_Float32
	FloatSeven   whereHelperfloat32
	FloatEight   whereHelpernull_Float32
	FloatNine    whereHelpernull_Float32
	ByteaZero    whereHelpernull_Bytes
	ByteaOne     whereHelpernull_Bytes
	ByteaTwo     whereHelper__byte
	ByteaThree   whereHelper__byte
	ByteaFour    whereHelpernull_Bytes
	ByteaFive    whereHelper__byte
	ByteaSix     whereHelpernull_Bytes
	ByteaSeven   whereHelper__byte
	ByteaEight   whereHelper__byte
	TimeZero     whereHelpernull_Time
	TimeOne      whereHelpernull_Time
	TimeTwo      whereHelpernull_Time
	TimeThree    whereHelpernull_Time
	TimeFive     whereHelpernull_Time
	TimeNine     whereHelpertime_Time
	TimeEleven   whereHelpernull_Time
	TimeTwelve   whereHelpertime_Time
	TimeFifteen  whereHelpernull_Time
	TimeSixteen  whereHelpertime_Time
}{
	ID:           whereHelperint{field: "`magic`.`id`"},
	IDTwo:        whereHelperint{field: "`magic`.`id_two`"},
	IDThree:      whereHelpernull_Int{field: "`magic`.`id_three`"},
	BoolZero:     whereHelpernull_Int8{field: "`magic`.`bool_zero`"},
	BoolOne:      whereHelpernull_Int8{field: "`magic`.`bool_one`"},
	BoolTwo:      whereHelperint8{field: "`magic`.`bool_two`"},
	BoolThree:    whereHelpernull_Int8{field: "`magic`.`bool_three`"},
	BoolFour:     whereHelpernull_Int8{field: "`magic`.`bool_four`"},
	BoolFive:     whereHelperint8{field: "`magic`.`bool_five`"},
	BoolSix:      whereHelperint8{field: "`magic`.`bool_six`"},
	StringZero:   whereHelpernull_String{field: "`magic`.`string_zero`"},
	StringOne:    whereHelpernull_String{field: "`magic`.`string_one`"},
	StringTwo:    whereHelperstring{field: "`magic`.`string_two`"},
	StringThree:  whereHelpernull_String{field: "`magic`.`string_three`"},
	StringFour:   whereHelperstring{field: "`magic`.`string_four`"},
	StringFive:   whereHelpernull_String{field: "`magic`.`string_five`"},
	StringSix:    whereHelpernull_String{field: "`magic`.`string_six`"},
	StringSeven:  whereHelperstring{field: "`magic`.`string_seven`"},
	StringEight:  whereHelpernull_String{field: "`magic`.`string_eight`"},
	StringNine:   whereHelperstring{field: "`magic`.`string_nine`"},
	StringTen:    whereHelpernull_String{field: "`magic`.`string_ten`"},
	StringEleven: whereHelperstring{field: "`magic`.`string_eleven`"},
	BigIntZero:   whereHelpernull_Int64{field: "`magic`.`big_int_zero`"},
	BigIntOne:    whereHelpernull_Int64{field: "`magic`.`big_int_one`"},
	BigIntTwo:    whereHelperint64{field: "`magic`.`big_int_two`"},
	BigIntThree:  whereHelpernull_Int64{field: "`magic`.`big_int_three`"},
	BigIntFour:   whereHelperint64{field: "`magic`.`big_int_four`"},
	BigIntFive:   whereHelpernull_Int64{field: "`magic`.`big_int_five`"},
	BigIntSix:    whereHelperint64{field: "`magic`.`big_int_six`"},
	IntZero:      whereHelpernull_Int{field: "`magic`.`int_zero`"},
	IntOne:       whereHelpernull_Int{field: "`magic`.`int_one`"},
	IntTwo:       whereHelperint{field: "`magic`.`int_two`"},
	IntThree:     whereHelpernull_Int{field: "`magic`.`int_three`"},
	IntFour:      whereHelperint{field: "`magic`.`int_four`"},
	IntFive:      whereHelpernull_Int{field: "`magic`.`int_five`"},
	IntSix:       whereHelperint{field: "`magic`.`int_six`"},
	FloatZero:    whereHelpernull_Float32{field: "`magic`.`float_zero`"},
	FloatOne:     whereHelpernull_Float32{field: "`magic`.`float_one`"},
	FloatTwo:     whereHelpernull_Float32{field: "`magic`.`float_two`"},
	FloatThree:   whereHelpernull_Float32{field: "`magic`.`float_three`"},
	FloatFour:    whereHelpernull_Float32{field: "`magic`.`float_four`"},
	FloatFive:    whereHelperfloat32{field: "`magic`.`float_five`"},
	FloatSix:     whereHelpernull_Float32{field: "`magic`.`float_six`"},
	FloatSeven:   whereHelperfloat32{field: "`magic`.`float_seven`"},
	FloatEight:   whereHelpernull_Float32{field: "`magic`.`float_eight`"},
	FloatNine:    whereHelpernull_Float32{field: "`magic`.`float_nine`"},
	ByteaZero:    whereHelpernull_Bytes{field: "`magic`.`bytea_zero`"},
	ByteaOne:     whereHelpernull_Bytes{field: "`magic`.`bytea_one`"},
	ByteaTwo:     whereHelper__byte{field: "`magic`.`bytea_two`"},
	ByteaThree:   whereHelper__byte{field: "`magic`.`bytea_three`"},
	ByteaFour:    whereHelpernull_Bytes{field: "`magic`.`bytea_four`"},
	ByteaFive:    whereHelper__byte{field: "`magic`.`bytea_five`"},
	ByteaSix:     whereHelpernull_Bytes{field: "`magic`.`bytea_six`"},
	ByteaSeven:   whereHelper__byte{field: "`magic`.`bytea_seven`"},
	ByteaEight:   whereHelper__byte{field: "`magic`.`bytea_eight`"},
	TimeZero:     whereHelpernull_Time{field: "`magic`.`time_zero`"},
	TimeOne:      whereHelpernull_Time{field: "`magic`.`time_one`"},
	TimeTwo:      whereHelpernull_Time{field: "`magic`.`time_two`"},
	TimeThree:    whereHelpernull_Time{field: "`magic`.`time_three`"},
	TimeFive:     whereHelpernull_Time{field: "`magic`.`time_five`"},
	TimeNine:     whereHelpertime_Time{field: "`magic`.`time_nine`"},
	TimeEleven:   whereHelpernull_Time{field: "`magic`.`time_eleven`"},
	TimeTwelve:   whereHelpertime_Time{field: "`magic`.`time_twelve`"},
	TimeFifteen:  whereHelpernull_Time{field: "`magic`.`time_fifteen`"},
	TimeSixteen:  whereHelpertime_Time{field: "`magic`.`time_sixteen`"},
}

// MagicRels is where relationship names are stored.
var MagicRels = struct {
}{}

// magicR is where relationships are stored.
type magicR struct {
}

// NewStruct creates a new relationship struct
func (*magicR) NewStruct() *magicR {
	return &magicR{}
}

// magicL is where Load methods for each relationship are stored.
type magicL struct{}

var (
	magicAllColumns            = []string{"id", "id_two", "id_three", "bool_zero", "bool_one", "bool_two", "bool_three", "bool_four", "bool_five", "bool_six", "string_zero", "string_one", "string_two", "string_three", "string_four", "string_five", "string_six", "string_seven", "string_eight", "string_nine", "string_ten", "string_eleven", "big_int_zero", "big_int_one", "big_int_two", "big_int_three", "big_int_four", "big_int_five", "big_int_six", "int_zero", "int_one", "int_two", "int_three", "int_four", "int_five", "int_six", "float_zero", "float_one", "float_two", "float_three", "float_four", "float_five", "float_six", "float_seven", "float_eight", "float_nine", "bytea_zero", "bytea_one", "bytea_two", "bytea_three", "bytea_four", "bytea_five", "bytea_six", "bytea_seven", "bytea_eight", "time_zero", "time_one", "time_two", "time_three", "time_five", "time_nine", "time_eleven", "time_twelve", "time_fifteen", "time_sixteen"}
	magicColumnsWithoutDefault = []string{"id_two", "id_three", "bool_zero", "bool_one", "bool_two", "string_zero", "string_one", "string_two", "string_five", "string_six", "string_seven", "string_ten", "string_eleven", "big_int_zero", "big_int_one", "big_int_two", "int_zero", "int_one", "int_two", "float_zero", "float_one", "float_two", "float_three", "float_four", "float_five", "bytea_zero", "bytea_one", "bytea_two", "time_zero", "time_one", "time_two", "time_three", "time_eleven", "time_twelve"}
	magicColumnsWithDefault    = []string{"id", "bool_three", "bool_four", "bool_five", "bool_six", "string_three", "string_four", "string_eight", "string_nine", "big_int_three", "big_int_four", "big_int_five", "big_int_six", "int_three", "int_four", "int_five", "int_six", "float_six", "float_seven", "float_eight", "float_nine", "bytea_three", "bytea_four", "bytea_five", "bytea_six", "bytea_seven", "bytea_eight", "time_five", "time_nine", "time_fifteen", "time_sixteen"}
	magicPrimaryKeyColumns     = []string{"id"}
	magicGeneratedColumns      = []string{}
)

type (
	// MagicSlice is an alias for a slice of pointers to Magic.
	// This should almost always be used instead of []Magic.
	MagicSlice []*Magic
	// MagicHook is the signature for custom Magic hook methods
	MagicHook func(context.Context, boil.ContextExecutor, *Magic) error

	magicQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	magicType                 = reflect.TypeOf(&Magic{})
	magicMapping              = queries.MakeStructMapping(magicType)
	magicPrimaryKeyMapping, _ = queries.BindMapping(magicType, magicMapping, magicPrimaryKeyColumns)
	magicInsertCacheMut       sync.RWMutex
	magicInsertCache          = make(map[string]insertCache)
	magicUpdateCacheMut       sync.RWMutex
	magicUpdateCache          = make(map[string]updateCache)
	magicUpsertCacheMut       sync.RWMutex
	magicUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var magicAfterSelectMu sync.Mutex
var magicAfterSelectHooks []MagicHook

var magicBeforeInsertMu sync.Mutex
var magicBeforeInsertHooks []MagicHook
var magicAfterInsertMu sync.Mutex
var magicAfterInsertHooks []MagicHook

var magicBeforeUpdateMu sync.Mutex
var magicBeforeUpdateHooks []MagicHook
var magicAfterUpdateMu sync.Mutex
var magicAfterUpdateHooks []MagicHook

var magicBeforeDeleteMu sync.Mutex
var magicBeforeDeleteHooks []MagicHook
var magicAfterDeleteMu sync.Mutex
var magicAfterDeleteHooks []MagicHook

var magicBeforeUpsertMu sync.Mutex
var magicBeforeUpsertHooks []MagicHook
var magicAfterUpsertMu sync.Mutex
var magicAfterUpsertHooks []MagicHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Magic) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Magic) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Magic) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Magic) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Magic) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Magic) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Magic) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Magic) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Magic) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddMagicHook registers your hook function for all future operations.
func AddMagicHook(hookPoint boil.HookPoint, magicHook MagicHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		magicAfterSelectMu.Lock()
		magicAfterSelectHooks = append(magicAfterSelectHooks, magicHook)
		magicAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		magicBeforeInsertMu.Lock()
		magicBeforeInsertHooks = append(magicBeforeInsertHooks, magicHook)
		magicBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		magicAfterInsertMu.Lock()
		magicAfterInsertHooks = append(magicAfterInsertHooks, magicHook)
		magicAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		magicBeforeUpdateMu.Lock()
		magicBeforeUpdateHooks = append(magicBeforeUpdateHooks, magicHook)
		magicBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		magicAfterUpdateMu.Lock()
		magicAfterUpdateHooks = append(magicAfterUpdateHooks, magicHook)
		magicAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		magicBeforeDeleteMu.Lock()
		magicBeforeDeleteHooks = append(magicBeforeDeleteHooks, magicHook)
		magicBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		magicAfterDeleteMu.Lock()
		magicAfterDeleteHooks = append(magicAfterDeleteHooks, magicHook)
		magicAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		magicBeforeUpsertMu.Lock()
		magicBeforeUpsertHooks = append(magicBeforeUpsertHooks, magicHook)
		magicBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		magicAfterUpsertMu.Lock()
		magicAfterUpsertHooks = append(magicAfterUpsertHooks, magicHook)
		magicAfterUpsertMu.Unlock()
	}
}

// One returns a single magic record from the query.
func (q magicQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Magic, error) {
	o := &Magic{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for magic")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Magic records from the query.
func (q magicQuery) All(ctx context.Context, exec boil.ContextExecutor) (MagicSlice, error) {
	var o []*Magic

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Magic slice")
	}

	if len(magicAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Magic records in the query.
func (q magicQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count magic rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q magicQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if magic exists")
	}

	return count > 0, nil
}

// Magics retrieves all the records using an executor.
func Magics(mods ...qm.QueryMod) magicQuery {
	mods = append(mods, qm.From("`magic`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`magic`.*"})
	}

	return magicQuery{q}
}

// FindMagic retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMagic(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Magic, error) {
	magicObj := &Magic{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `magic` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, magicObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from magic")
	}

	if err = magicObj.doAfterSelectHooks(ctx, exec); err != nil {
		return magicObj, err
	}

	return magicObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Magic) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no magic provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(magicColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	magicInsertCacheMut.RLock()
	cache, cached := magicInsertCache[key]
	magicInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			magicAllColumns,
			magicColumnsWithDefault,
			magicColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(magicType, magicMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(magicType, magicMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `magic` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `magic` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `magic` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, magicPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into magic")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == magicMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for magic")
	}

CacheNoHooks:
	if !cached {
		magicInsertCacheMut.Lock()
		magicInsertCache[key] = cache
		magicInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Magic.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Magic) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	magicUpdateCacheMut.RLock()
	cache, cached := magicUpdateCache[key]
	magicUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			magicAllColumns,
			magicPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update magic, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `magic` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, magicPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(magicType, magicMapping, append(wl, magicPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update magic row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for magic")
	}

	if !cached {
		magicUpdateCacheMut.Lock()
		magicUpdateCache[key] = cache
		magicUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q magicQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for magic")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for magic")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MagicSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), magicPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `magic` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, magicPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in magic slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all magic")
	}
	return rowsAff, nil
}

var mySQLMagicUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Magic) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no magic provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(magicColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLMagicUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	magicUpsertCacheMut.RLock()
	cache, cached := magicUpsertCache[key]
	magicUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			magicAllColumns,
			magicColumnsWithDefault,
			magicColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			magicAllColumns,
			magicPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert magic, could not build update column list")
		}

		ret := strmangle.SetComplement(magicAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`magic`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `magic` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(magicType, magicMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(magicType, magicMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for magic")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == magicMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(magicType, magicMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for magic")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for magic")
	}

CacheNoHooks:
	if !cached {
		magicUpsertCacheMut.Lock()
		magicUpsertCache[key] = cache
		magicUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Magic record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Magic) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Magic provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), magicPrimaryKeyMapping)
	sql := "DELETE FROM `magic` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from magic")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for magic")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q magicQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no magicQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from magic")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for magic")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MagicSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(magicBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), magicPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `magic` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, magicPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from magic slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for magic")
	}

	if len(magicAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Magic) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMagic(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MagicSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MagicSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), magicPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `magic`.* FROM `magic` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, magicPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in MagicSlice")
	}

	*o = slice

	return nil
}

// MagicExists checks if the Magic row exists.
func MagicExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `magic` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if magic exists")
	}

	return exists, nil
}

// Exists checks if the Magic row exists.
func (o *Magic) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return MagicExists(ctx, exec, o.ID)
}
