// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Magicest is an object representing the database table.
type Magicest struct {
	ID   int          `boil:"id" json:"id" toml:"id" yaml:"id"`
	Aa   null.String  `boil:"aa" json:"aa,omitempty" toml:"aa" yaml:"aa,omitempty"`
	BB   string       `boil:"bb" json:"bb" toml:"bb" yaml:"bb"`
	KK   null.Float64 `boil:"kk" json:"kk,omitempty" toml:"kk" yaml:"kk,omitempty"`
	LL   float64      `boil:"ll" json:"ll" toml:"ll" yaml:"ll"`
	MM   null.Int8    `boil:"mm" json:"mm,omitempty" toml:"mm" yaml:"mm,omitempty"`
	NN   int8         `boil:"nn" json:"nn" toml:"nn" yaml:"nn"`
	Oo   null.Int8    `boil:"oo" json:"oo,omitempty" toml:"oo" yaml:"oo,omitempty"`
	PP   int8         `boil:"pp" json:"pp" toml:"pp" yaml:"pp"`
	QQ   null.Int16   `boil:"qq" json:"qq,omitempty" toml:"qq" yaml:"qq,omitempty"`
	RR   int16        `boil:"rr" json:"rr" toml:"rr" yaml:"rr"`
	SS   null.Int32   `boil:"ss" json:"ss,omitempty" toml:"ss" yaml:"ss,omitempty"`
	TT   int32        `boil:"tt" json:"tt" toml:"tt" yaml:"tt"`
	Uu   null.Int64   `boil:"uu" json:"uu,omitempty" toml:"uu" yaml:"uu,omitempty"`
	VV   int64        `boil:"vv" json:"vv" toml:"vv" yaml:"vv"`
	WW   null.Float32 `boil:"ww" json:"ww,omitempty" toml:"ww" yaml:"ww,omitempty"`
	XX   float32      `boil:"xx" json:"xx" toml:"xx" yaml:"xx"`
	Yy   null.Float64 `boil:"yy" json:"yy,omitempty" toml:"yy" yaml:"yy,omitempty"`
	ZZ   float64      `boil:"zz" json:"zz" toml:"zz" yaml:"zz"`
	Aaa  null.Float64 `boil:"aaa" json:"aaa,omitempty" toml:"aaa" yaml:"aaa,omitempty"`
	BBB  float64      `boil:"bbb" json:"bbb" toml:"bbb" yaml:"bbb"`
	CCC  null.Float64 `boil:"ccc" json:"ccc,omitempty" toml:"ccc" yaml:"ccc,omitempty"`
	DDD  float64      `boil:"ddd" json:"ddd" toml:"ddd" yaml:"ddd"`
	Eee  null.Int8    `boil:"eee" json:"eee,omitempty" toml:"eee" yaml:"eee,omitempty"`
	FFF  int8         `boil:"fff" json:"fff" toml:"fff" yaml:"fff"`
	GGG  null.Time    `boil:"ggg" json:"ggg,omitempty" toml:"ggg" yaml:"ggg,omitempty"`
	HHH  time.Time    `boil:"hhh" json:"hhh" toml:"hhh" yaml:"hhh"`
	Iii  null.Time    `boil:"iii" json:"iii,omitempty" toml:"iii" yaml:"iii,omitempty"`
	JJJ  time.Time    `boil:"jjj" json:"jjj" toml:"jjj" yaml:"jjj"`
	KKK  null.Time    `boil:"kkk" json:"kkk,omitempty" toml:"kkk" yaml:"kkk,omitempty"`
	LLL  time.Time    `boil:"lll" json:"lll" toml:"lll" yaml:"lll"`
	MMM  null.Bytes   `boil:"mmm" json:"mmm,omitempty" toml:"mmm" yaml:"mmm,omitempty"`
	NNN  []byte       `boil:"nnn" json:"nnn" toml:"nnn" yaml:"nnn"`
	Ooo  null.Bytes   `boil:"ooo" json:"ooo,omitempty" toml:"ooo" yaml:"ooo,omitempty"`
	PPP  []byte       `boil:"ppp" json:"ppp" toml:"ppp" yaml:"ppp"`
	QQQ  null.Bytes   `boil:"qqq" json:"qqq,omitempty" toml:"qqq" yaml:"qqq,omitempty"`
	RRR  []byte       `boil:"rrr" json:"rrr" toml:"rrr" yaml:"rrr"`
	SSS  null.Bytes   `boil:"sss" json:"sss,omitempty" toml:"sss" yaml:"sss,omitempty"`
	TTT  []byte       `boil:"ttt" json:"ttt" toml:"ttt" yaml:"ttt"`
	Uuu  null.Bytes   `boil:"uuu" json:"uuu,omitempty" toml:"uuu" yaml:"uuu,omitempty"`
	VVV  []byte       `boil:"vvv" json:"vvv" toml:"vvv" yaml:"vvv"`
	WWW  null.Bytes   `boil:"www" json:"www,omitempty" toml:"www" yaml:"www,omitempty"`
	XXX  []byte       `boil:"xxx" json:"xxx" toml:"xxx" yaml:"xxx"`
	Yyy  null.String  `boil:"yyy" json:"yyy,omitempty" toml:"yyy" yaml:"yyy,omitempty"`
	ZZZ  string       `boil:"zzz" json:"zzz" toml:"zzz" yaml:"zzz"`
	Aaaa null.String  `boil:"aaaa" json:"aaaa,omitempty" toml:"aaaa" yaml:"aaaa,omitempty"`
	BBBB string       `boil:"bbbb" json:"bbbb" toml:"bbbb" yaml:"bbbb"`
	CCCC null.String  `boil:"cccc" json:"cccc,omitempty" toml:"cccc" yaml:"cccc,omitempty"`
	DDDD string       `boil:"dddd" json:"dddd" toml:"dddd" yaml:"dddd"`
	Eeee null.Int8    `boil:"eeee" json:"eeee,omitempty" toml:"eeee" yaml:"eeee,omitempty"`
	FFFF int8         `boil:"ffff" json:"ffff" toml:"ffff" yaml:"ffff"`

	R *magicestR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L magicestL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MagicestColumns = struct {
	ID   string
	Aa   string
	BB   string
	KK   string
	LL   string
	MM   string
	NN   string
	Oo   string
	PP   string
	QQ   string
	RR   string
	SS   string
	TT   string
	Uu   string
	VV   string
	WW   string
	XX   string
	Yy   string
	ZZ   string
	Aaa  string
	BBB  string
	CCC  string
	DDD  string
	Eee  string
	FFF  string
	GGG  string
	HHH  string
	Iii  string
	JJJ  string
	KKK  string
	LLL  string
	MMM  string
	NNN  string
	Ooo  string
	PPP  string
	QQQ  string
	RRR  string
	SSS  string
	TTT  string
	Uuu  string
	VVV  string
	WWW  string
	XXX  string
	Yyy  string
	ZZZ  string
	Aaaa string
	BBBB string
	CCCC string
	DDDD string
	Eeee string
	FFFF string
}{
	ID:   "id",
	Aa:   "aa",
	BB:   "bb",
	KK:   "kk",
	LL:   "ll",
	MM:   "mm",
	NN:   "nn",
	Oo:   "oo",
	PP:   "pp",
	QQ:   "qq",
	RR:   "rr",
	SS:   "ss",
	TT:   "tt",
	Uu:   "uu",
	VV:   "vv",
	WW:   "ww",
	XX:   "xx",
	Yy:   "yy",
	ZZ:   "zz",
	Aaa:  "aaa",
	BBB:  "bbb",
	CCC:  "ccc",
	DDD:  "ddd",
	Eee:  "eee",
	FFF:  "fff",
	GGG:  "ggg",
	HHH:  "hhh",
	Iii:  "iii",
	JJJ:  "jjj",
	KKK:  "kkk",
	LLL:  "lll",
	MMM:  "mmm",
	NNN:  "nnn",
	Ooo:  "ooo",
	PPP:  "ppp",
	QQQ:  "qqq",
	RRR:  "rrr",
	SSS:  "sss",
	TTT:  "ttt",
	Uuu:  "uuu",
	VVV:  "vvv",
	WWW:  "www",
	XXX:  "xxx",
	Yyy:  "yyy",
	ZZZ:  "zzz",
	Aaaa: "aaaa",
	BBBB: "bbbb",
	CCCC: "cccc",
	DDDD: "dddd",
	Eeee: "eeee",
	FFFF: "ffff",
}

var MagicestTableColumns = struct {
	ID   string
	Aa   string
	BB   string
	KK   string
	LL   string
	MM   string
	NN   string
	Oo   string
	PP   string
	QQ   string
	RR   string
	SS   string
	TT   string
	Uu   string
	VV   string
	WW   string
	XX   string
	Yy   string
	ZZ   string
	Aaa  string
	BBB  string
	CCC  string
	DDD  string
	Eee  string
	FFF  string
	GGG  string
	HHH  string
	Iii  string
	JJJ  string
	KKK  string
	LLL  string
	MMM  string
	NNN  string
	Ooo  string
	PPP  string
	QQQ  string
	RRR  string
	SSS  string
	TTT  string
	Uuu  string
	VVV  string
	WWW  string
	XXX  string
	Yyy  string
	ZZZ  string
	Aaaa string
	BBBB string
	CCCC string
	DDDD string
	Eeee string
	FFFF string
}{
	ID:   "magicest.id",
	Aa:   "magicest.aa",
	BB:   "magicest.bb",
	KK:   "magicest.kk",
	LL:   "magicest.ll",
	MM:   "magicest.mm",
	NN:   "magicest.nn",
	Oo:   "magicest.oo",
	PP:   "magicest.pp",
	QQ:   "magicest.qq",
	RR:   "magicest.rr",
	SS:   "magicest.ss",
	TT:   "magicest.tt",
	Uu:   "magicest.uu",
	VV:   "magicest.vv",
	WW:   "magicest.ww",
	XX:   "magicest.xx",
	Yy:   "magicest.yy",
	ZZ:   "magicest.zz",
	Aaa:  "magicest.aaa",
	BBB:  "magicest.bbb",
	CCC:  "magicest.ccc",
	DDD:  "magicest.ddd",
	Eee:  "magicest.eee",
	FFF:  "magicest.fff",
	GGG:  "magicest.ggg",
	HHH:  "magicest.hhh",
	Iii:  "magicest.iii",
	JJJ:  "magicest.jjj",
	KKK:  "magicest.kkk",
	LLL:  "magicest.lll",
	MMM:  "magicest.mmm",
	NNN:  "magicest.nnn",
	Ooo:  "magicest.ooo",
	PPP:  "magicest.ppp",
	QQQ:  "magicest.qqq",
	RRR:  "magicest.rrr",
	SSS:  "magicest.sss",
	TTT:  "magicest.ttt",
	Uuu:  "magicest.uuu",
	VVV:  "magicest.vvv",
	WWW:  "magicest.www",
	XXX:  "magicest.xxx",
	Yyy:  "magicest.yyy",
	ZZZ:  "magicest.zzz",
	Aaaa: "magicest.aaaa",
	BBBB: "magicest.bbbb",
	CCCC: "magicest.cccc",
	DDDD: "magicest.dddd",
	Eeee: "magicest.eeee",
	FFFF: "magicest.ffff",
}

// Generated where

type whereHelpernull_Float64 struct{ field string }

func (w whereHelpernull_Float64) EQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float64) NEQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float64) LT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float64) LTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float64) GT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float64) GTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float64) IN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float64) NIN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperfloat64 struct{ field string }

func (w whereHelperfloat64) EQ(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperfloat64) NEQ(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperfloat64) LT(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperfloat64) LTE(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperfloat64) GT(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperfloat64) GTE(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperfloat64) IN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperfloat64) NIN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int16 struct{ field string }

func (w whereHelpernull_Int16) EQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int16) NEQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int16) LT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int16) LTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int16) GT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int16) GTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int16) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int16) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperint16 struct{ field string }

func (w whereHelperint16) EQ(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint16) NEQ(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint16) LT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint16) LTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint16) GT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint16) GTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int32 struct{ field string }

func (w whereHelpernull_Int32) EQ(x null.Int32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int32) NEQ(x null.Int32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int32) LT(x null.Int32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int32) LTE(x null.Int32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int32) GT(x null.Int32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int32) GTE(x null.Int32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int32) IN(slice []int32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int32) NIN(slice []int32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int32) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int32) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperint32 struct{ field string }

func (w whereHelperint32) EQ(x int32) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint32) NEQ(x int32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint32) LT(x int32) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint32) LTE(x int32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint32) GT(x int32) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint32) GTE(x int32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint32) IN(slice []int32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint32) NIN(slice []int32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var MagicestWhere = struct {
	ID   whereHelperint
	Aa   whereHelpernull_String
	BB   whereHelperstring
	KK   whereHelpernull_Float64
	LL   whereHelperfloat64
	MM   whereHelpernull_Int8
	NN   whereHelperint8
	Oo   whereHelpernull_Int8
	PP   whereHelperint8
	QQ   whereHelpernull_Int16
	RR   whereHelperint16
	SS   whereHelpernull_Int32
	TT   whereHelperint32
	Uu   whereHelpernull_Int64
	VV   whereHelperint64
	WW   whereHelpernull_Float32
	XX   whereHelperfloat32
	Yy   whereHelpernull_Float64
	ZZ   whereHelperfloat64
	Aaa  whereHelpernull_Float64
	BBB  whereHelperfloat64
	CCC  whereHelpernull_Float64
	DDD  whereHelperfloat64
	Eee  whereHelpernull_Int8
	FFF  whereHelperint8
	GGG  whereHelpernull_Time
	HHH  whereHelpertime_Time
	Iii  whereHelpernull_Time
	JJJ  whereHelpertime_Time
	KKK  whereHelpernull_Time
	LLL  whereHelpertime_Time
	MMM  whereHelpernull_Bytes
	NNN  whereHelper__byte
	Ooo  whereHelpernull_Bytes
	PPP  whereHelper__byte
	QQQ  whereHelpernull_Bytes
	RRR  whereHelper__byte
	SSS  whereHelpernull_Bytes
	TTT  whereHelper__byte
	Uuu  whereHelpernull_Bytes
	VVV  whereHelper__byte
	WWW  whereHelpernull_Bytes
	XXX  whereHelper__byte
	Yyy  whereHelpernull_String
	ZZZ  whereHelperstring
	Aaaa whereHelpernull_String
	BBBB whereHelperstring
	CCCC whereHelpernull_String
	DDDD whereHelperstring
	Eeee whereHelpernull_Int8
	FFFF whereHelperint8
}{
	ID:   whereHelperint{field: "`magicest`.`id`"},
	Aa:   whereHelpernull_String{field: "`magicest`.`aa`"},
	BB:   whereHelperstring{field: "`magicest`.`bb`"},
	KK:   whereHelpernull_Float64{field: "`magicest`.`kk`"},
	LL:   whereHelperfloat64{field: "`magicest`.`ll`"},
	MM:   whereHelpernull_Int8{field: "`magicest`.`mm`"},
	NN:   whereHelperint8{field: "`magicest`.`nn`"},
	Oo:   whereHelpernull_Int8{field: "`magicest`.`oo`"},
	PP:   whereHelperint8{field: "`magicest`.`pp`"},
	QQ:   whereHelpernull_Int16{field: "`magicest`.`qq`"},
	RR:   whereHelperint16{field: "`magicest`.`rr`"},
	SS:   whereHelpernull_Int32{field: "`magicest`.`ss`"},
	TT:   whereHelperint32{field: "`magicest`.`tt`"},
	Uu:   whereHelpernull_Int64{field: "`magicest`.`uu`"},
	VV:   whereHelperint64{field: "`magicest`.`vv`"},
	WW:   whereHelpernull_Float32{field: "`magicest`.`ww`"},
	XX:   whereHelperfloat32{field: "`magicest`.`xx`"},
	Yy:   whereHelpernull_Float64{field: "`magicest`.`yy`"},
	ZZ:   whereHelperfloat64{field: "`magicest`.`zz`"},
	Aaa:  whereHelpernull_Float64{field: "`magicest`.`aaa`"},
	BBB:  whereHelperfloat64{field: "`magicest`.`bbb`"},
	CCC:  whereHelpernull_Float64{field: "`magicest`.`ccc`"},
	DDD:  whereHelperfloat64{field: "`magicest`.`ddd`"},
	Eee:  whereHelpernull_Int8{field: "`magicest`.`eee`"},
	FFF:  whereHelperint8{field: "`magicest`.`fff`"},
	GGG:  whereHelpernull_Time{field: "`magicest`.`ggg`"},
	HHH:  whereHelpertime_Time{field: "`magicest`.`hhh`"},
	Iii:  whereHelpernull_Time{field: "`magicest`.`iii`"},
	JJJ:  whereHelpertime_Time{field: "`magicest`.`jjj`"},
	KKK:  whereHelpernull_Time{field: "`magicest`.`kkk`"},
	LLL:  whereHelpertime_Time{field: "`magicest`.`lll`"},
	MMM:  whereHelpernull_Bytes{field: "`magicest`.`mmm`"},
	NNN:  whereHelper__byte{field: "`magicest`.`nnn`"},
	Ooo:  whereHelpernull_Bytes{field: "`magicest`.`ooo`"},
	PPP:  whereHelper__byte{field: "`magicest`.`ppp`"},
	QQQ:  whereHelpernull_Bytes{field: "`magicest`.`qqq`"},
	RRR:  whereHelper__byte{field: "`magicest`.`rrr`"},
	SSS:  whereHelpernull_Bytes{field: "`magicest`.`sss`"},
	TTT:  whereHelper__byte{field: "`magicest`.`ttt`"},
	Uuu:  whereHelpernull_Bytes{field: "`magicest`.`uuu`"},
	VVV:  whereHelper__byte{field: "`magicest`.`vvv`"},
	WWW:  whereHelpernull_Bytes{field: "`magicest`.`www`"},
	XXX:  whereHelper__byte{field: "`magicest`.`xxx`"},
	Yyy:  whereHelpernull_String{field: "`magicest`.`yyy`"},
	ZZZ:  whereHelperstring{field: "`magicest`.`zzz`"},
	Aaaa: whereHelpernull_String{field: "`magicest`.`aaaa`"},
	BBBB: whereHelperstring{field: "`magicest`.`bbbb`"},
	CCCC: whereHelpernull_String{field: "`magicest`.`cccc`"},
	DDDD: whereHelperstring{field: "`magicest`.`dddd`"},
	Eeee: whereHelpernull_Int8{field: "`magicest`.`eeee`"},
	FFFF: whereHelperint8{field: "`magicest`.`ffff`"},
}

// MagicestRels is where relationship names are stored.
var MagicestRels = struct {
}{}

// magicestR is where relationships are stored.
type magicestR struct {
}

// NewStruct creates a new relationship struct
func (*magicestR) NewStruct() *magicestR {
	return &magicestR{}
}

// magicestL is where Load methods for each relationship are stored.
type magicestL struct{}

var (
	magicestAllColumns            = []string{"id", "aa", "bb", "kk", "ll", "mm", "nn", "oo", "pp", "qq", "rr", "ss", "tt", "uu", "vv", "ww", "xx", "yy", "zz", "aaa", "bbb", "ccc", "ddd", "eee", "fff", "ggg", "hhh", "iii", "jjj", "kkk", "lll", "mmm", "nnn", "ooo", "ppp", "qqq", "rrr", "sss", "ttt", "uuu", "vvv", "www", "xxx", "yyy", "zzz", "aaaa", "bbbb", "cccc", "dddd", "eeee", "ffff"}
	magicestColumnsWithoutDefault = []string{"aa", "bb", "kk", "ll", "mm", "nn", "oo", "pp", "qq", "rr", "ss", "tt", "uu", "vv", "ww", "xx", "yy", "zz", "aaa", "bbb", "ccc", "ddd", "eee", "fff", "ggg", "hhh", "iii", "jjj", "kkk", "mmm", "nnn", "ooo", "ppp", "qqq", "rrr", "sss", "ttt", "uuu", "vvv", "www", "xxx", "yyy", "zzz", "aaaa", "bbbb", "cccc", "dddd", "eeee", "ffff"}
	magicestColumnsWithDefault    = []string{"id", "lll"}
	magicestPrimaryKeyColumns     = []string{"id"}
	magicestGeneratedColumns      = []string{}
)

type (
	// MagicestSlice is an alias for a slice of pointers to Magicest.
	// This should almost always be used instead of []Magicest.
	MagicestSlice []*Magicest
	// MagicestHook is the signature for custom Magicest hook methods
	MagicestHook func(context.Context, boil.ContextExecutor, *Magicest) error

	magicestQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	magicestType                 = reflect.TypeOf(&Magicest{})
	magicestMapping              = queries.MakeStructMapping(magicestType)
	magicestPrimaryKeyMapping, _ = queries.BindMapping(magicestType, magicestMapping, magicestPrimaryKeyColumns)
	magicestInsertCacheMut       sync.RWMutex
	magicestInsertCache          = make(map[string]insertCache)
	magicestUpdateCacheMut       sync.RWMutex
	magicestUpdateCache          = make(map[string]updateCache)
	magicestUpsertCacheMut       sync.RWMutex
	magicestUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var magicestAfterSelectMu sync.Mutex
var magicestAfterSelectHooks []MagicestHook

var magicestBeforeInsertMu sync.Mutex
var magicestBeforeInsertHooks []MagicestHook
var magicestAfterInsertMu sync.Mutex
var magicestAfterInsertHooks []MagicestHook

var magicestBeforeUpdateMu sync.Mutex
var magicestBeforeUpdateHooks []MagicestHook
var magicestAfterUpdateMu sync.Mutex
var magicestAfterUpdateHooks []MagicestHook

var magicestBeforeDeleteMu sync.Mutex
var magicestBeforeDeleteHooks []MagicestHook
var magicestAfterDeleteMu sync.Mutex
var magicestAfterDeleteHooks []MagicestHook

var magicestBeforeUpsertMu sync.Mutex
var magicestBeforeUpsertHooks []MagicestHook
var magicestAfterUpsertMu sync.Mutex
var magicestAfterUpsertHooks []MagicestHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Magicest) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Magicest) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Magicest) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Magicest) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Magicest) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Magicest) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Magicest) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Magicest) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Magicest) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range magicestAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddMagicestHook registers your hook function for all future operations.
func AddMagicestHook(hookPoint boil.HookPoint, magicestHook MagicestHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		magicestAfterSelectMu.Lock()
		magicestAfterSelectHooks = append(magicestAfterSelectHooks, magicestHook)
		magicestAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		magicestBeforeInsertMu.Lock()
		magicestBeforeInsertHooks = append(magicestBeforeInsertHooks, magicestHook)
		magicestBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		magicestAfterInsertMu.Lock()
		magicestAfterInsertHooks = append(magicestAfterInsertHooks, magicestHook)
		magicestAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		magicestBeforeUpdateMu.Lock()
		magicestBeforeUpdateHooks = append(magicestBeforeUpdateHooks, magicestHook)
		magicestBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		magicestAfterUpdateMu.Lock()
		magicestAfterUpdateHooks = append(magicestAfterUpdateHooks, magicestHook)
		magicestAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		magicestBeforeDeleteMu.Lock()
		magicestBeforeDeleteHooks = append(magicestBeforeDeleteHooks, magicestHook)
		magicestBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		magicestAfterDeleteMu.Lock()
		magicestAfterDeleteHooks = append(magicestAfterDeleteHooks, magicestHook)
		magicestAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		magicestBeforeUpsertMu.Lock()
		magicestBeforeUpsertHooks = append(magicestBeforeUpsertHooks, magicestHook)
		magicestBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		magicestAfterUpsertMu.Lock()
		magicestAfterUpsertHooks = append(magicestAfterUpsertHooks, magicestHook)
		magicestAfterUpsertMu.Unlock()
	}
}

// One returns a single magicest record from the query.
func (q magicestQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Magicest, error) {
	o := &Magicest{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for magicest")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Magicest records from the query.
func (q magicestQuery) All(ctx context.Context, exec boil.ContextExecutor) (MagicestSlice, error) {
	var o []*Magicest

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Magicest slice")
	}

	if len(magicestAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Magicest records in the query.
func (q magicestQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count magicest rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q magicestQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if magicest exists")
	}

	return count > 0, nil
}

// Magicests retrieves all the records using an executor.
func Magicests(mods ...qm.QueryMod) magicestQuery {
	mods = append(mods, qm.From("`magicest`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`magicest`.*"})
	}

	return magicestQuery{q}
}

// FindMagicest retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMagicest(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Magicest, error) {
	magicestObj := &Magicest{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `magicest` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, magicestObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from magicest")
	}

	if err = magicestObj.doAfterSelectHooks(ctx, exec); err != nil {
		return magicestObj, err
	}

	return magicestObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Magicest) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no magicest provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(magicestColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	magicestInsertCacheMut.RLock()
	cache, cached := magicestInsertCache[key]
	magicestInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			magicestAllColumns,
			magicestColumnsWithDefault,
			magicestColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(magicestType, magicestMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(magicestType, magicestMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `magicest` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `magicest` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `magicest` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, magicestPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into magicest")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == magicestMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for magicest")
	}

CacheNoHooks:
	if !cached {
		magicestInsertCacheMut.Lock()
		magicestInsertCache[key] = cache
		magicestInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Magicest.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Magicest) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	magicestUpdateCacheMut.RLock()
	cache, cached := magicestUpdateCache[key]
	magicestUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			magicestAllColumns,
			magicestPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update magicest, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `magicest` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, magicestPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(magicestType, magicestMapping, append(wl, magicestPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update magicest row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for magicest")
	}

	if !cached {
		magicestUpdateCacheMut.Lock()
		magicestUpdateCache[key] = cache
		magicestUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q magicestQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for magicest")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for magicest")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MagicestSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), magicestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `magicest` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, magicestPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in magicest slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all magicest")
	}
	return rowsAff, nil
}

var mySQLMagicestUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Magicest) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no magicest provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(magicestColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLMagicestUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	magicestUpsertCacheMut.RLock()
	cache, cached := magicestUpsertCache[key]
	magicestUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			magicestAllColumns,
			magicestColumnsWithDefault,
			magicestColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			magicestAllColumns,
			magicestPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert magicest, could not build update column list")
		}

		ret := strmangle.SetComplement(magicestAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`magicest`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `magicest` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(magicestType, magicestMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(magicestType, magicestMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for magicest")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == magicestMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(magicestType, magicestMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for magicest")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for magicest")
	}

CacheNoHooks:
	if !cached {
		magicestUpsertCacheMut.Lock()
		magicestUpsertCache[key] = cache
		magicestUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Magicest record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Magicest) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Magicest provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), magicestPrimaryKeyMapping)
	sql := "DELETE FROM `magicest` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from magicest")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for magicest")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q magicestQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no magicestQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from magicest")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for magicest")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MagicestSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(magicestBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), magicestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `magicest` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, magicestPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from magicest slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for magicest")
	}

	if len(magicestAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Magicest) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMagicest(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MagicestSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MagicestSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), magicestPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `magicest`.* FROM `magicest` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, magicestPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in MagicestSlice")
	}

	*o = slice

	return nil
}

// MagicestExists checks if the Magicest row exists.
func MagicestExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `magicest` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if magicest exists")
	}

	return exists, nil
}

// Exists checks if the Magicest row exists.
func (o *Magicest) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return MagicestExists(ctx, exec, o.ID)
}
